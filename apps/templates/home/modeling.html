{% extends "layouts/base.html" %}

{% block title %} Modelagem {% endblock %} 

<!-- Specific Page CSS goes HERE  -->
{% block stylesheets %}
<style>
    /* Estilos CSS para a barra lateral */
    .sidebar_modeling {
        width: 200px;
        height: 480px;
        background-color: #f0f0f0;
        float: left;
        overflow-y: auto;
        display: flex;
        flex-wrap: wrap;
    }

    .toolButton {
        width: 70px;
        padding: 10px;
        margin: 10px;
        cursor: pointer;
        border: 1px solid #ccc;
        background-color: #fff;
        text-align: center;
    }
    #graphContainer {
        margin-left: 220px; /* Adapte a margem para acomodar a barra lateral */
    }
    .modalStyle {
        display: none;
        position: fixed;
    }



    input[type="file"] {
            display: none;
        }

        /* Style the custom button */
        .custom-file-input {
            display: inline-block;
            padding: 10px 15px;
            font-size: 16px;
            font-weight: bold;
            color: #fff;
            background-color: #495a65;
            border: 1px solid #2980b9;
            border-radius: 5px;
            cursor: pointer;
            opacity: 1;
            width: 250px;
        }

        /* Style for the selected file name display */
        .file-name {
            margin-top: 10px;
            opacity: 1;
        }

        /* Add hover effect for better user interaction */
        .custom-file-input:hover {
            background-color: #89acd3;
        }
    
</style>
{% endblock stylesheets %}

{% block content %}

    <div class="content">
        <div class="row">
            <div class="col-md-12">
                <div class="card ">
                  <div class="card-header">
                    <h4 class="card-title">Modelagem</h4>
                  </div>
                  <div class="card-body">
                    <div class="sidebar_modeling">
                        <div class="toolButton" id="classButton"><img src="../../static/assets/img/class.png" alt="Classe" title="Classe"></div>
                        <!--<div class="toolButton" id="associationButton">Adicionar Associação</div>-->
                        <div class="toolButton" id="addUseCaseButton"><img src="../../static/assets/img/usecase.png" alt="Caso de Uso" title="Caso de Uso"></div>
                        <div class="toolButton" id="addActorButton"><img src="../../static/assets/img/actor.png" alt="Ator" title="Ator"></div>
                        <div class="toolButton" id="addObjectIoTButton"><img src="../../static/assets/img/iotobject.png" alt="Objeto IoT" title="Objeto IoT"></div>
                        <div class="toolButton" id="addSensorButton"><img src="../../static/assets/img/sensor.png" alt="Sensor" title="Sensor"></div>
                        <div class="toolButton" id="addActuatorButton"><img src="../../static/assets/img/actuator.png" alt="Atuador" title="Atuador"></div>
                        <div class="toolButton" id="addContainerStateButton"><img src="../../static/assets/img/containerState.png" alt="Container" title="Container"></div>
                        <div class="toolButton" id="addStateButton"><img src="../../static/assets/img/state.png" alt="Estado" title="Estado"></div>
                        <div class="toolButton" id="addStartStateButton"><img src="../../static/assets/img/startState.png" alt="Estado Inicial" title="Estado Inicial"></div>
                        <div class="toolButton" id="addDecisionButton"><img src="../../static/assets/img/decision.png" alt="Tomada de decisão" title="Tomada de decisão"></div>
                        <div class="toolButton" id="addEndStateButton"><img src="../../static/assets/img/endState.png" alt="Estado Final" title="Estado Final"></div>
                        <div class="toolButton" id="addObjectButton"><img src="../../static/assets/img/stateThing.png" alt="Objeto" title="Objeto"></div>
                        <div class="toolButton" id="addValueTypeButton"><img src="../../static/assets/img/valuetype.png" alt="Tipo Valor" title="Tipo Valor"></div>
                        <div class="toolButton" id="addBlockButton"><img src="../../static/assets/img/block.png" alt="Bloco" title="Bloco"></div>
                        <div class="toolButton" id="addObjectLifeLineButton"><img src="../../static/assets/img/objectlifeline.png" height="70px" alt="Linha de Vida" title="Linha de Vida"></div>
                        <div class="toolButton" id="addActorLifeLineButton"><img src="../../static/assets/img/actorlifeline.png" height="70px" alt="Ator Linha de Vida" title="Ator Linha de Vida"></div>
                        <div class="toolButton" id="addActivationBarButton"><img src="../../static/assets/img/ativacao.png" height="70px"alt="Barra de Ativação" title="Barra de Ativação"></div>
                        <div class="toolButton" id="addLine1Button"><img src="../../static/assets/img/linha1.png" height="70px"  alt="linha" title="Linha"></div>
                        <div class="toolButton" id="addLine2Button"><img src="../../static/assets/img/linha2.png" height="70px"alt="linha" title="linha"></div>
                        <div class="toolButton" id="addLine3Button"><img src="../../static/assets/img/linha3.png" height="70px"alt="linha" title="linha"></div>
                        <div class="toolButton" id="addLine4Button"><img src="../../static/assets/img/linha4.png" height="70px"alt="linha" title="linha"></div>
                        <div class="toolButton" id="addLine5Button"><img src="../../static/assets/img/linha5.png" height="70px"alt="linha" title="linha"></div>
                        <div class="toolButton" id="addLine6Button"><img src="../../static/assets/img/linha6.png" height="70px"alt="linha" title="linha"></div>
                        <div class="toolButton" id="addLine7Button"><img src="../../static/assets/img/linha7.png" height="70px"alt="linha" title="linha"></div>
                        <div class="toolButton" id="addLine8Button"><img src="../../static/assets/img/linha8.png" height="70px"alt="linha" title="linha"></div>
                        <div class="toolButton" id="addLine9Button"><img src="../../static/assets/img/linha9.png" height="70px"alt="linha" title="linha"></div>
                        <div class="toolButton" id="addLine10Button"><img src="../../static/assets/img/linha10.png" height="70px"alt="linha" title="linha"></div>
                        <div class="toolButton" id="addLine11Button"><img src="../../static/assets/img/linha11.png" height="70px"alt="linha" title="linha"></div>
                        <div class="toolButton" id="addLine12Button"><img src="../../static/assets/img/linha12.png" height="70px"alt="linha" title="linha"></div>
                        <div class="" id=""><label id="" for="imageInput" class=""  style="width:70px;
                            padding: 10px;
                            margin: 10px;
                            cursor: pointer;
                            border: 1px solid #ccc;
                            background-color: #fff;
                            text-align: center;"><img id="" src="../../static/assets/img/import.png" height="90px"></label>
                            <input type="file" id="imageInput"  accept="image/*"></div>
                        

                        <!-- Adicione mais botões ou funcionalidades à barra lateral, se necessário -->
                    </div>
                    <div id="graphContainer" style="width: calc(100% - 220px); height: 500px; border: solid;"></div>
                    
                    <label id="downloadXMLButton" class="custom-file-input" style="color: #f0f0f0;">Download em XML</label>
                    <label id="downloadPDFButton" class="custom-file-input" style="color: #f0f0f0;">Download em PDF</label>
                    <label id="downloadPNGButton" class="custom-file-input" style="color: #f0f0f0;">Download em Imagem</label>
                    


                    <label id="fileNameDisplay" for="fileInput" class="custom-file-input" style="color: #f0f0f0;width: 400px;">Esolha um arquivo .xml:</label>
                    <input type="file" id="fileInput"  accept=".xml">


                    <div class="table-responsive">
                       <!-- Botão para acionar modal -->
                        <button type="button" class="btn btn-primary" data-toggle="modal" data-target="#modalExemplo">
                            Novo Diagrama
                        </button>
                        
                        <!-- Modal -->
                        <div class="modal fade" id="modalExemplo" tabindex="-1" role="dialog" aria-labelledby="exampleModalLabel" aria-hidden="true">
                            <div class="modal-dialog" role="document" style="max-width: 1200px;">
                            <div class="modal-content">
                                <div class="modal-header">
                                
                                <button type="button" class="close" data-dismiss="modal" aria-label="Fechar">
                                    <span aria-hidden="true">&times;</span>
                                </button>
                                </div>
                                <div class="modal-body">
                                    <div class="form-group">
                                        <label for="projeto-nome" class="col-form-label">Nome do Diagrama:</label>
                                        <input type="text" class="form-control" id="projeto-nome">
                                        <label for="projeto-nome" class="col-form-label">Linguagem de Modelagem:</label>
                                        <select class="form-control">
                                            <option value="uml">UML</option>
                                            <option value="sysml">SysML</option>
                                            <option value="sysiotml">SysIoTML</option>                                            
                                        </select>
                                        <label for="projeto-nome" class="col-form-label">Tipo do Diagrama:</label>
                                        <select class="form-control">
                                            <option value="usecase">Diagrama de Caso de Uso</option>
                                            <option value="seq">Diagrama de Sequencia</option>
                                            <option value="block">Diagrama de Bloco</option>
                                            <option value="machine">Diagrama de Máquina de Estado</option>
                                        </select>
                                    </div>
                                </div>
                                <div class="modal-footer">
                                <button type="button" class="btn btn-secondary" data-dismiss="modal">Fechar</button>
                                <a href="choice.html">
                                    <button type="button" class="btn btn-primary">Salvar diagrama</button>
                                </a>
                                </div>
                            </div>
                            </div>
                        </div>
                    </div>
                    <div class="table-responsive">
                        <table class="table tablesorter " id="">
                          <thead class=" text-primary">
                            <tr>
                              <th>
                                ID
                              </th>
                              <th>
                                Tipo
                              </th>
                              <th>
                                Nome
                              </th>
                              <th class="text-center">
                                
                              </th>
                              <th class="text-center">
                                
                              </th>
                              <th class="text-center">
                                
                              </th>
                            </tr>
                          </thead>
                          <tbody>
                            <tr>
                              <td>
                                Dakota Rice
                              </td>
                              <td>
                                00\00\0000
                              </td>
                              <td>
                                OK
                              </td>
                              <td class="text-center">
                                <i class="tim-icons icon-upload"></i>
                              </td>
                              <td class="text-center">
                                <i class="tim-icons icon-pencil"></i>
                              </td>
                              <td class="text-center">
                                <i class="tim-icons icon-trash-simple"></i>                                
                              </td>
                            </tr>
                            
                          </tbody>
                        </table>
                      </div>
                  </div>
                </div>
              </div>
    </div>

    <!-- Modal -->
    <div class="modal fade modalStyle" id="modalStyle" tabindex="-1" role="dialog" aria-labelledby="exampleModalLabel" aria-hidden="true">
        <div class="modal-dialog" role="document" style="width: 400px; height: 400px;float: right;overflow-y: auto;">
        <div class="modal-content">
            <div class="modal-header">
            
            <button type="button" class="close" data-dismiss="modal" aria-label="Fechar">
                <span aria-hidden="true">&times;</span>
            </button>
            </div>
        
            <div class="modal-body">
                <div class="form-group">
                    <label for="labelInput">Texto:</label>
                    <input type="text" id="labelInput" onchange="setLabel()" class="form-control" >
                </br>
                    <label for="fontInput">Fonte:</label>
                    <select class="form-control" id="fontInput" onchange="setFont()">
                        <option value="Arial">-----</option>
                        <option value="Arial">Arial</option>
                        <option value="Helvetica">Helvetica</option>
                        <option value="Times New Roman">Times New Roman</option>
                        <option value="Courier New">Courier New</option>
                        <option value="Verdana">Verdana</option>
                        <option value="Georgia">Georgia</option>
                        <option value="Palatino">Palatino</option>
                        <option value="Garamond">Garamond</option>
                    </select>
                </br>
                    <label for="fontSizeInput">Tamanho da Fonte:</label>
                    <input type="number" id="fontSizeInput"  onchange="setFontSize()" class="form-control" >
                    
                </br>
                    <label for="labelColorInput">Cor do Texto:</label>
                    <input type="color" id="labelColorInput" placeholder="Enter label color" onchange="setLabelColor()" class="form-control" >
                </br>
                    <label for="projeto-nome" class="col-form-label">Cor:</label>
                    <input type="color" id="head" name="head" value="#e66465" onchange="updateFillColor()" class="form-control" >
                </div>
            </div>
        </div>
        </div>
    </div>

{% endblock content %}

<!-- Specific Page JS goes HERE  -->
{% block javascripts %}
<script src="https://cdn.jsdelivr.net/npm/mxgraph@4.2.2/javascript/mxClient.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/canvg/3.0.0/rgbcolor.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/canvg/3.0.0/canvg.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dom-to-image/2.6.0/dom-to-image.min.js"></script>


  <script>
    // Display selected file name
    function displayFileName(input) {
        
        
    }
</script>

<script>
    // Inicialização do mxGraph
    const container = document.getElementById('graphContainer');
    const graph = new mxGraph(container);

    const parent = graph.getDefaultParent();
    
    let elementoType;

    let source, target;
    let creatingEdge = false;

    function createGraph(container) {

        graph.addListener(mxEvent.DOUBLE_CLICK, function(sender, evt) {
            const cell = evt.getProperty('cell');
            if (cell && cell.isVertex()) {
                if (!source) {
                    source = cell;
                } else if (!target && cell !== source) {
                    target = cell;
                    createEdge();
                }
            }
        });

    }

    function createEdge() {
        graph.getModel().beginUpdate();
        try {
            const edge = graph.insertEdge(graph.getDefaultParent(), null, 'Associação', source, target);
            edge.getGeometry().points = [new mxPoint(source.getGeometry().x + source.getGeometry().width / 2, source.getGeometry().y + source.getGeometry().height / 2),
                new mxPoint(target.getGeometry().x + target.getGeometry().width / 2, target.getGeometry().y + target.getGeometry().height / 2)];
            edge.setConnectable(false);
            source = null;
            target = null;
        } finally {
            graph.getModel().endUpdate();
        }
    }

    function handleSaveButtonClick(){
            // Salva o estado atual do grafo
            const encoder = new mxCodec();
            const node = encoder.encode(graph.getModel());
            const xml = new XMLSerializer().serializeToString(node);

        // Envia o XML para a view Django usando uma solicitação AJAX
        fetch('/salvar_modelagem', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/xml',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: xml
            })
            .then(response => {
            if (!response.ok) {
                throw new Error('Erro ao enviar o XML para a view Django. Status: ' + response.status);
            }
            console.log('XML enviado com sucesso para a view Django.');
            })
            .catch(error => {
            console.error('Erro ao enviar o XML para a view Django:', error);
            });
    }

    //cria Class
    document.getElementById('classButton').addEventListener('click', function() {
        const vertex = graph.insertVertex(graph.getDefaultParent(), null, 'Classe', 100, 100, 120, 60, 'whiteSpace=wrap;fillColor=#FFFFFF;strokeColor=#000000;');
        
        // isso faz criação de coneção de seta
        graph.connectionHandler.addListener(mxEvent.CONNECT, function (sender, evt) {
        const edge = evt.getProperty('cell'); 
        const source = graph.getModel().getTerminal(edge, true); 
        const target = graph.getModel().getTerminal(edge, false); 
        if (source === vertex) {
            // A aresta está conectada ao objeto conectável
            console.log('Conectado ao objeto conectável');
        }
        });

        const style = graph.getStylesheet().getDefaultEdgeStyle();
        style[mxConstants.STYLE_STROKECOLOR] = '#000000'; 
        style[mxConstants.STYLE_STROKEWIDTH] = 2; 
        style[mxConstants.STYLE_ENDARROW] = 'classic'; 

        graph.setConnectable(true);
        graph.setMultigraph(false); 
        graph.connectionHandler.setCreateTarget(true);
        graph.connectionHandler.setCreateTargetMarker(new mxMarker(graph, '#00FF00', 8));

        // Habilita a desconexão de arestas
        graph.setDisconnectOnMove(false);

        // Configura o estilo da conexão (opcional)
        graph.connectionHandler.createEdgeState = function (me) {
            const edge = graph.createEdge(null, null, null, null, null, 'edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;endArrow=classic;');
            return new mxCellState(this.graph.view, edge, this.graph.getCellStyle(edge));
        };
    });

    //Botão Caso de Uso
    document.getElementById('addUseCaseButton').addEventListener('click', function() {
        const vertex = graph.insertVertex( parent,  null,  'Caso de Uso',  180,  180,  120,  80,  mxConstants.STYLE_SHAPE + '=ellipse;whiteSpace=wrap;fillColor=#FFFFFF;strokeColor=#000000;');
        
        // isso faz criação de coneção de seta
        graph.connectionHandler.addListener(mxEvent.CONNECT, function (sender, evt) {
        const edge = evt.getProperty('cell'); 
        const source = graph.getModel().getTerminal(edge, true); 
        const target = graph.getModel().getTerminal(edge, false); 
        if (source === vertex) {
            // A aresta está conectada ao objeto conectável
            console.log('Conectado ao objeto conectável');
        }
        });

        const style = graph.getStylesheet().getDefaultEdgeStyle();
        style[mxConstants.STYLE_STROKECOLOR] = '#000000'; 
        style[mxConstants.STYLE_STROKEWIDTH] = 2; 
        style[mxConstants.STYLE_ENDARROW] = 'open'; 

        graph.setConnectable(true);
        graph.setMultigraph(false); 
        graph.connectionHandler.setCreateTarget(true);
        graph.connectionHandler.setCreateTargetMarker(new mxMarker(graph, '#00FF00', 8));

        // Habilita a desconexão de arestas
        graph.setDisconnectOnMove(false);

        // Configura o estilo da conexão (opcional)
        graph.connectionHandler.createEdgeState = function (me) {
            const edge = graph.createEdge(null, null, null, null, null, 'edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;endArrow=open;');
            return new mxCellState(this.graph.view, edge, this.graph.getCellStyle(edge));
        };
       
    });

    //Botão Ator
    document.getElementById('addActorButton').addEventListener('click', function() {
        const parent = graph.getDefaultParent();
        const x = 100; 
        const y = 100; 
        const width = 80; 
        const height = 120; 

        
        const actorIconUrl = '../../static/assets/img/actor.png';

        const vertex = graph.insertVertex(
        parent,
        null,
        'Ator',
        x,
        y,
        width,
        height,
        'shape=image;image=' + actorIconUrl + ';align=center;verticalAlign=bottom;'
        );

   

        
        graph.refresh();

        vertex.setVertex(true); 
        // isso faz criação de coneção de seta
        graph.connectionHandler.addListener(mxEvent.CONNECT, function (sender, evt) {
        const edge = evt.getProperty('cell'); 
        const source = graph.getModel().getTerminal(edge, true); 
        const target = graph.getModel().getTerminal(edge, false); 
        if (source === vertex) {
            // A aresta está conectada ao objeto conectável
            console.log('Conectado ao objeto conectável');
        }
        });

        const style = graph.getStylesheet().getDefaultEdgeStyle();
        style[mxConstants.STYLE_STROKECOLOR] = '#000000'; 
        style[mxConstants.STYLE_STROKEWIDTH] = 2; 
        style[mxConstants.STYLE_ENDARROW] = 'classic'; 

        graph.setConnectable(true);
        graph.setMultigraph(false); 
        graph.connectionHandler.setCreateTarget(true);
        graph.connectionHandler.setCreateTargetMarker(new mxMarker(graph, '#00FF00', 8));

        // Habilita a desconexão de arestas
        graph.setDisconnectOnMove(false);

        // Configura o estilo da conexão (opcional)
        graph.connectionHandler.createEdgeState = function (me) {
            const edge = graph.createEdge(null, null, null, null, null, 'edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;endArrow=classic;');
            return new mxCellState(this.graph.view, edge, this.graph.getCellStyle(edge));
        };
    });

    //Botão Objeto IoT
    document.getElementById('addObjectIoTButton').addEventListener('click', function() {
        const parent = graph.getDefaultParent();
        const x = 100; 
        const y = 100; 
        const width = 80; 
        const height = 120; 

        
        const actorIconUrl = '../../static/assets/img/iotobject.png';

        const vertex = graph.insertVertex(
        parent,
        null,
        'Objeto IoT',
        x,
        y,
        width,
        height,
        'shape=image;image=' + actorIconUrl+ ';align=center;verticalAlign=bottom;'
        );


        
        graph.refresh();

        vertex.setVertex(true); 
        // isso faz criação de coneção de seta
        graph.connectionHandler.addListener(mxEvent.CONNECT, function (sender, evt) {
        const edge = evt.getProperty('cell'); 
        const source = graph.getModel().getTerminal(edge, true); 
        const target = graph.getModel().getTerminal(edge, false); 
        if (source === vertex) {
            // A aresta está conectada ao objeto conectável
            console.log('Conectado ao objeto conectável');
        }
        });

        const style = graph.getStylesheet().getDefaultEdgeStyle();
        style[mxConstants.STYLE_STROKECOLOR] = '#000000'; 
        style[mxConstants.STYLE_STROKEWIDTH] = 2; 
        style[mxConstants.STYLE_ENDARROW] = 'classic'; 

        graph.setConnectable(true);
        graph.setMultigraph(false); 
        graph.connectionHandler.setCreateTarget(true);
        graph.connectionHandler.setCreateTargetMarker(new mxMarker(graph, '#00FF00', 8));

        // Habilita a desconexão de arestas
        graph.setDisconnectOnMove(false);

        // Configura o estilo da conexão (opcional)
        graph.connectionHandler.createEdgeState = function (me) {
            const edge = graph.createEdge(null, null, null, null, null, 'edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;endArrow=classic;');
            return new mxCellState(this.graph.view, edge, this.graph.getCellStyle(edge));
        }; 
    });

    //Botão Sensor
    document.getElementById('addSensorButton').addEventListener('click', function() {
        const parent = graph.getDefaultParent();
        const x = 100; 
        const y = 100; 
        const width = 80; 
        const height = 120; 

        
        const actorIconUrl = '../../static/assets/img/sensor.png';

        const vertex = graph.insertVertex(
        parent,
        null,
        'Sensor',
        x,
        y,
        width,
        height,
        'shape=image;image=' + actorIconUrl+ ';align=center;verticalAlign=bottom;'
        );

        

        
        graph.refresh();

        vertex.setVertex(true); 
        // isso faz criação de coneção de seta
        graph.connectionHandler.addListener(mxEvent.CONNECT, function (sender, evt) {
        const edge = evt.getProperty('cell'); 
        const source = graph.getModel().getTerminal(edge, true); 
        const target = graph.getModel().getTerminal(edge, false); 
        if (source === vertex) {
            // A aresta está conectada ao objeto conectável
            console.log('Conectado ao objeto conectável');
        }
        });

        const style = graph.getStylesheet().getDefaultEdgeStyle();
        style[mxConstants.STYLE_STROKECOLOR] = '#000000'; 
        style[mxConstants.STYLE_STROKEWIDTH] = 2; 
        style[mxConstants.STYLE_ENDARROW] = 'classic'; 

        graph.setConnectable(true);
        graph.setMultigraph(false); 
        graph.connectionHandler.setCreateTarget(true);
        graph.connectionHandler.setCreateTargetMarker(new mxMarker(graph, '#00FF00', 8));

        // Habilita a desconexão de arestas
        graph.setDisconnectOnMove(false);

        // Configura o estilo da conexão (opcional)
        graph.connectionHandler.createEdgeState = function (me) {
            const edge = graph.createEdge(null, null, null, null, null, 'edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;endArrow=classic;');
            return new mxCellState(this.graph.view, edge, this.graph.getCellStyle(edge));
        };
    });

    //Botão Atuador
    document.getElementById('addActuatorButton').addEventListener('click', function() {
        const parent = graph.getDefaultParent();
        const x = 100; 
        const y = 100; 
        const width = 80; 
        const height = 120; 

        
        const actorIconUrl = '../../static/assets/img/actuator.png';

        const vertex = graph.insertVertex(
        parent,
        null,
        'Atuador',
        x,
        y,
        width,
        height,
        'shape=image;image=' + actorIconUrl+ ';align=center;verticalAlign=bottom;'
        );

        

        
        graph.refresh();

        vertex.setVertex(true); 
        // isso faz criação de coneção de seta
        graph.connectionHandler.addListener(mxEvent.CONNECT, function (sender, evt) {
        const edge = evt.getProperty('cell'); 
        const source = graph.getModel().getTerminal(edge, true); 
        const target = graph.getModel().getTerminal(edge, false); 
        if (source === vertex) {
            // A aresta está conectada ao objeto conectável
            console.log('Conectado ao objeto conectável');
        }
        });

        const style = graph.getStylesheet().getDefaultEdgeStyle();
        style[mxConstants.STYLE_STROKECOLOR] = '#000000'; 
        style[mxConstants.STYLE_STROKEWIDTH] = 2; 
        style[mxConstants.STYLE_ENDARROW] = 'classic'; 

        graph.setConnectable(true);
        graph.setMultigraph(false); 
        graph.connectionHandler.setCreateTarget(true);
        graph.connectionHandler.setCreateTargetMarker(new mxMarker(graph, '#00FF00', 8));

        // Habilita a desconexão de arestas
        graph.setDisconnectOnMove(false);

        // Configura o estilo da conexão (opcional)
        graph.connectionHandler.createEdgeState = function (me) {
            const edge = graph.createEdge(null, null, null, null, null, 'edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;endArrow=classic;');
            return new mxCellState(this.graph.view, edge, this.graph.getCellStyle(edge));
        };
    });

    //Botão tomada de decisao
    document.getElementById('addDecisionButton').addEventListener('click', function() {
        const parent = graph.getDefaultParent();
        const x = 100; 
        const y = 100; 
        const width = 80; 
        const height = 80; 

        
        const actorIconUrl = '../../static/assets/img/decision.png';

        const vertex = graph.insertVertex(
        parent,
        null,
        '',
        x,
        y,
        width,
        height,
        'shape=image;image=' + actorIconUrl+ ';align=center;verticalAlign=bottom;'
        );

       

        
        graph.refresh();

        vertex.setVertex(true); 
        // isso faz criação de coneção de seta
        graph.connectionHandler.addListener(mxEvent.CONNECT, function (sender, evt) {
        const edge = evt.getProperty('cell'); 
        const source = graph.getModel().getTerminal(edge, true); 
        const target = graph.getModel().getTerminal(edge, false); 
        if (source === vertex) {
            // A aresta está conectada ao objeto conectável
            console.log('Conectado ao objeto conectável');
        }
        });

        const style = graph.getStylesheet().getDefaultEdgeStyle();
        style[mxConstants.STYLE_STROKECOLOR] = '#000000'; 
        style[mxConstants.STYLE_STROKEWIDTH] = 2; 
        style[mxConstants.STYLE_ENDARROW] = 'classic'; 

        graph.setConnectable(true);
        graph.setMultigraph(false); 
        graph.connectionHandler.setCreateTarget(true);
        graph.connectionHandler.setCreateTargetMarker(new mxMarker(graph, '#00FF00', 8));

        // Habilita a desconexão de arestas
        graph.setDisconnectOnMove(false);

        // Configura o estilo da conexão (opcional)
        graph.connectionHandler.createEdgeState = function (me) {
            const edge = graph.createEdge(null, null, null, null, null, 'edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;endArrow=classic;');
            return new mxCellState(this.graph.view, edge, this.graph.getCellStyle(edge));
        };
    });

    //Botão Container ME
    document.getElementById('addContainerStateButton').addEventListener('click', function() {
        const parent = graph.getDefaultParent();
        const x = 0; 
        const y = 0; 
        const width = 480; 
        const height = 340; 

        
        const actorIconUrl = '../../static/assets/img/containerState.png';

        const vertex = graph.insertVertex(
        parent,
        null,
        'sm',
        x,
        y,
        width,
        height,
        'shape=image;image=' + actorIconUrl+ ';align=left;verticalAlign=top;'
        );


        
        graph.refresh();

        vertex.setVertex(true); 
        // isso faz criação de coneção de seta
        graph.connectionHandler.addListener(mxEvent.CONNECT, function (sender, evt) {
        const edge = evt.getProperty('cell'); 
        const source = graph.getModel().getTerminal(edge, true); 
        const target = graph.getModel().getTerminal(edge, false); 
        if (source === vertex) {
            // A aresta está conectada ao objeto conectável
            console.log('Conectado ao objeto conectável');
        }
        });

        const style = graph.getStylesheet().getDefaultEdgeStyle();
        style[mxConstants.STYLE_STROKECOLOR] = '#000000'; 
        style[mxConstants.STYLE_STROKEWIDTH] = 2; 
        style[mxConstants.STYLE_ENDARROW] = 'classic'; 

        graph.setConnectable(true);
        graph.setMultigraph(false); 
        graph.connectionHandler.setCreateTarget(true);
        graph.connectionHandler.setCreateTargetMarker(new mxMarker(graph, '#00FF00', 8));

        // Habilita a desconexão de arestas
        graph.setDisconnectOnMove(false);

        // Configura o estilo da conexão (opcional)
        graph.connectionHandler.createEdgeState = function (me) {
            const edge = graph.createEdge(null, null, null, null, null, 'edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;endArrow=classic;');
            return new mxCellState(this.graph.view, edge, this.graph.getCellStyle(edge));
        };
    });

    //Botão Estado Simples
    document.getElementById('addStateButton').addEventListener('click', function() {
        const parent = graph.getDefaultParent();
        const x = 100; 
        const y = 100; 
        const width = 120; 
        const height = 40; 

        
        const actorIconUrl = '../../static/assets/img/state.png';

        const vertex = graph.insertVertex(
        parent,
        null,
        'Estado Simples',
        x,
        y,
        width,
        height,
        'shape=image;image=' + actorIconUrl
        );


        
        graph.refresh();

        vertex.setVertex(true); 
        // isso faz criação de coneção de seta
        graph.connectionHandler.addListener(mxEvent.CONNECT, function (sender, evt) {
        const edge = evt.getProperty('cell'); 
        const source = graph.getModel().getTerminal(edge, true); 
        const target = graph.getModel().getTerminal(edge, false); 
        if (source === vertex) {
            // A aresta está conectada ao objeto conectável
            console.log('Conectado ao objeto conectável');
        }
        });

        const style = graph.getStylesheet().getDefaultEdgeStyle();
        style[mxConstants.STYLE_STROKECOLOR] = '#000000'; 
        style[mxConstants.STYLE_STROKEWIDTH] = 2; 
        style[mxConstants.STYLE_ENDARROW] = 'classic'; 

        graph.setConnectable(true);
        graph.setMultigraph(false); 
        graph.connectionHandler.setCreateTarget(true);
        graph.connectionHandler.setCreateTargetMarker(new mxMarker(graph, '#00FF00', 8));

        // Habilita a desconexão de arestas
        graph.setDisconnectOnMove(false);

        // Configura o estilo da conexão (opcional)
        graph.connectionHandler.createEdgeState = function (me) {
            const edge = graph.createEdge(null, null, null, null, null, 'edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;endArrow=classic;');
            return new mxCellState(this.graph.view, edge, this.graph.getCellStyle(edge));
        };
    });

    //Botão Estado Inicial
    document.getElementById('addStartStateButton').addEventListener('click', function() {
        const parent = graph.getDefaultParent();
        const x = 100; 
        const y = 100; 
        const width = 40; 
        const height = 30; 

        
        const actorIconUrl = '../../static/assets/img/startState.png';

        const vertex = graph.insertVertex(
        parent,
        null,
        '',
        x,
        y,
        width,
        height,
        'shape=image;image=' + actorIconUrl
        );


        
        graph.refresh();

        vertex.setVertex(true); 
        // isso faz criação de coneção de seta
        graph.connectionHandler.addListener(mxEvent.CONNECT, function (sender, evt) {
        const edge = evt.getProperty('cell'); 
        const source = graph.getModel().getTerminal(edge, true); 
        const target = graph.getModel().getTerminal(edge, false); 
        if (source === vertex) {
            // A aresta está conectada ao objeto conectável
            console.log('Conectado ao objeto conectável');
        }
        });

        const style = graph.getStylesheet().getDefaultEdgeStyle();
        style[mxConstants.STYLE_STROKECOLOR] = '#000000'; 
        style[mxConstants.STYLE_STROKEWIDTH] = 2; 
        style[mxConstants.STYLE_ENDARROW] = 'classic'; 

        graph.setConnectable(true);
        graph.setMultigraph(false); 
        graph.connectionHandler.setCreateTarget(true);
        graph.connectionHandler.setCreateTargetMarker(new mxMarker(graph, '#00FF00', 8));

        // Habilita a desconexão de arestas
        graph.setDisconnectOnMove(false);

        // Configura o estilo da conexão (opcional)
        graph.connectionHandler.createEdgeState = function (me) {
            const edge = graph.createEdge(null, null, null, null, null, 'edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;endArrow=classic;');
            return new mxCellState(this.graph.view, edge, this.graph.getCellStyle(edge));
        };
    });

    //Botão Estado Final
    document.getElementById('addEndStateButton').addEventListener('click', function() {
        const parent = graph.getDefaultParent();
        const x = 100; 
        const y = 100; 
        const width = 40; 
        const height = 30; 

        
        const actorIconUrl = '../../static/assets/img/endState.png';

        const vertex = graph.insertVertex(
        parent,
        null,
        '',
        x,
        y,
        width,
        height,
        'shape=image;image=' + actorIconUrl
        );


        
        graph.refresh();

        vertex.setVertex(true); 
        // isso faz criação de coneção de seta
        graph.connectionHandler.addListener(mxEvent.CONNECT, function (sender, evt) {
        const edge = evt.getProperty('cell'); 
        const source = graph.getModel().getTerminal(edge, true); 
        const target = graph.getModel().getTerminal(edge, false); 
        if (source === vertex) {
            // A aresta está conectada ao objeto conectável
            console.log('Conectado ao objeto conectável');
        }
        });

        const style = graph.getStylesheet().getDefaultEdgeStyle();
        style[mxConstants.STYLE_STROKECOLOR] = '#000000'; 
        style[mxConstants.STYLE_STROKEWIDTH] = 2; 
        style[mxConstants.STYLE_ENDARROW] = 'classic'; 

        graph.setConnectable(true);
        graph.setMultigraph(false); 
        graph.connectionHandler.setCreateTarget(true);
        graph.connectionHandler.setCreateTargetMarker(new mxMarker(graph, '#00FF00', 8));

        // Habilita a desconexão de arestas
        graph.setDisconnectOnMove(false);

        // Configura o estilo da conexão (opcional)
        graph.connectionHandler.createEdgeState = function (me) {
            const edge = graph.createEdge(null, null, null, null, null, 'edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;endArrow=classic;');
            return new mxCellState(this.graph.view, edge, this.graph.getCellStyle(edge));
        };
    });

    //Botão Objeto
    document.getElementById('addObjectButton').addEventListener('click', function() {
        const parent = graph.getDefaultParent();
        const x = 100; 
        const y = 100; 
        const width = 460; 
        const height = 340; 

        
        const actorIconUrl = '../../static/assets/img/stateThing.png';

        const vertex = graph.insertVertex(
        parent,
        null,
        'Objeto',
        x,
        y,
        width,
        height,
        'shape=image;image=' + actorIconUrl+ ';align=center;verticalAlign=top;'
        );

  

        
        graph.refresh();

        vertex.setVertex(true); 
        // isso faz criação de coneção de seta
        graph.connectionHandler.addListener(mxEvent.CONNECT, function (sender, evt) {
        const edge = evt.getProperty('cell'); 
        const source = graph.getModel().getTerminal(edge, true); 
        const target = graph.getModel().getTerminal(edge, false); 
        if (source === vertex) {
            // A aresta está conectada ao objeto conectável
            console.log('Conectado ao objeto conectável');
        }
        });

        const style = graph.getStylesheet().getDefaultEdgeStyle();
        style[mxConstants.STYLE_STROKECOLOR] = '#000000'; 
        style[mxConstants.STYLE_STROKEWIDTH] = 2; 
        style[mxConstants.STYLE_ENDARROW] = 'classic'; 

        graph.setConnectable(true);
        graph.setMultigraph(false); 
        graph.connectionHandler.setCreateTarget(true);
        graph.connectionHandler.setCreateTargetMarker(new mxMarker(graph, '#00FF00', 8));

        // Habilita a desconexão de arestas
        graph.setDisconnectOnMove(false);

        // Configura o estilo da conexão (opcional)
        graph.connectionHandler.createEdgeState = function (me) {
            const edge = graph.createEdge(null, null, null, null, null, 'edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;endArrow=classic;');
            return new mxCellState(this.graph.view, edge, this.graph.getCellStyle(edge));
        }; 
    });

    //Botão ValueType
    document.getElementById('addValueTypeButton').addEventListener('click', function() {
        const parent = graph.getDefaultParent();

        // Inserindo um Value Type (retângulo)
        const valueType = graph.insertVertex(
        parent,
        null,
        '', // Nome ou rótulo do Value Type
        100,
        100,
        210,
        150,
        'shape=rectangle;whiteSpace=wrap;fillColor=#FFFFFF;strokeColor=#000000;'
        );

        valueType.setVertex(true); 

        // Inserindo propriedades dentro do Value Type
        const property1 = graph.insertVertex(
        valueType,
        null,
        'Object IoT/Sensor/Actuator', // Propriedade 1 (Nome: Tipo)
        0,
        0,
        210,
        50,
        'shape=rectangle;whiteSpace=wrap;fillColor=#FFFFFF;strokeColor=#000000;'
        );

        const property2 = graph.insertVertex(
        valueType,
        null,
        'values', // Propriedade 2 (Nome: Tipo)
        0,
        50,
        210,
        50,
        'shape=rectangle;whiteSpace=wrap;fillColor=#FFFFFF;strokeColor=#000000;'
        );

        const property3 = graph.insertVertex(
        valueType,
        null,
        'properties', // Propriedade 2 (Nome: Tipo)
        0,
        100,
        210,
        50,
        'shape=rectangle;whiteSpace=wrap;fillColor=#FFFFFF;strokeColor=#000000;'
        );

        property1.setVertex(true); 
        property1.setConnectable(false); 

        property2.setVertex(true); 
        property2.setConnectable(false); 

        property3.setVertex(true); 
        property3.setConnectable(false); 

        // isso faz criação de coneção de seta
        graph.connectionHandler.addListener(mxEvent.CONNECT, function (sender, evt) {
        const edge = evt.getProperty('cell'); 
        const source = graph.getModel().getTerminal(edge, true); 
        const target = graph.getModel().getTerminal(edge, false); 
        if (source === valueType) {
            // A aresta está conectada ao objeto conectável
            console.log('Conectado ao objeto conectável');
        }
        });

        const style = graph.getStylesheet().getDefaultEdgeStyle();
        style[mxConstants.STYLE_STROKECOLOR] = '#000000'; 
        style[mxConstants.STYLE_STROKEWIDTH] = 2; 
        style[mxConstants.STYLE_ENDARROW] = 'classic'; 

        graph.setConnectable(true);
        graph.setMultigraph(false); 
        graph.connectionHandler.setCreateTarget(true);
        graph.connectionHandler.setCreateTargetMarker(new mxMarker(graph, '#00FF00', 8));

        // Habilita a desconexão de arestas
        graph.setDisconnectOnMove(false);

        // Configura o estilo da conexão (opcional)
        graph.connectionHandler.createEdgeState = function (me) {
            const edge = graph.createEdge(null, null, null, null, null, 'edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;endArrow=classic;');
            return new mxCellState(this.graph.view, edge, this.graph.getCellStyle(edge));
        };

    });

    //Botão ValueType
    document.getElementById('addBlockButton').addEventListener('click', function() {
        const parent = graph.getDefaultParent();

        // Inserindo um Value Type (retângulo)
        const valueType = graph.insertVertex(
        parent,
        null,
        '', // Nome ou rótulo do Value Type
        100,
        100,
        210,
        100,
        'shape=rectangle;whiteSpace=wrap;fillColor=#FFFFFF;strokeColor=#000000;'
        );

        valueType.setVertex(true); 

        // Inserindo propriedades dentro do Value Type
        const property1 = graph.insertVertex(
        valueType,
        null,
        'Block', // Propriedade 1 (Nome: Tipo)
        0,
        0,
        210,
        20,
        'shape=rectangle;whiteSpace=wrap;fillColor=#FFFFFF;strokeColor=#000000;'
        );

        const property2 = graph.insertVertex(
        valueType,
        null,
        'namespace', // Propriedade 2 (Nome: Tipo)
        0,
        20,
        210,
        90,
        'shape=rectangle;whiteSpace=wrap;fillColor=#FFFFFF;strokeColor=#000000;'
        );

        property1.setVertex(true); 
        property1.setConnectable(false); 

        property2.setVertex(true); 
        property2.setConnectable(false); 

        // isso faz criação de coneção de seta
        graph.connectionHandler.addListener(mxEvent.CONNECT, function (sender, evt) {
        const edge = evt.getProperty('cell'); 
        const source = graph.getModel().getTerminal(edge, true); 
        const target = graph.getModel().getTerminal(edge, false); 
        if (source === valueType) {
            // A aresta está conectada ao objeto conectável
            console.log('Conectado ao objeto conectável');
        }
        });

        const style = graph.getStylesheet().getDefaultEdgeStyle();
        style[mxConstants.STYLE_STROKECOLOR] = '#000000'; 
        style[mxConstants.STYLE_STROKEWIDTH] = 2; 
        style[mxConstants.STYLE_ENDARROW] = 'classic'; 

        graph.setConnectable(true);
        graph.setMultigraph(false); 
        graph.connectionHandler.setCreateTarget(true);
        graph.connectionHandler.setCreateTargetMarker(new mxMarker(graph, '#00FF00', 8));

        // Habilita a desconexão de arestas
        graph.setDisconnectOnMove(false);

        // Configura o estilo da conexão (opcional)
        graph.connectionHandler.createEdgeState = function (me) {
            const edge = graph.createEdge(null, null, null, null, null, 'edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;endArrow=classic;');
            return new mxCellState(this.graph.view, edge, this.graph.getCellStyle(edge));
        };

    });

    //Botão Objeto Linha de Vida
    document.getElementById('addObjectLifeLineButton').addEventListener('click', function() {
        const parent = graph.getDefaultParent();
        const x = 100; 
        const y = 100; 
        const width = 90; 
        const height = 350; 

        
        const actorIconUrl = '../../static/assets/img/objectlifeline.png';

        const vertex = graph.insertVertex(
        parent,
        null,
        'Object IoT/Sensor/Actuator',
        x,
        y,
        width,
        height,
        'shape=image;image=' + actorIconUrl
        );

        vertex.geometry.offset = new mxPoint(0, 0);
        vertex.geometry.relative = false;
        vertex.geometry.anchorPoint = new mxPoint(0, 0);
        vertex.geometry.relative = false;
        vertex.geometry.labelPosition = mxConstants.ALIGN_LEFT + mxConstants.ALIGN_BOTTOM;

        vertex.style += ';verticalAlign=top;'; 

        
        graph.refresh();

        vertex.setVertex(true); 
        
        // isso faz criação de coneção de seta
        graph.connectionHandler.addListener(mxEvent.CONNECT, function (sender, evt) {
        const edge = evt.getProperty('cell'); 
        const source = graph.getModel().getTerminal(edge, true); 
        const target = graph.getModel().getTerminal(edge, false); 
        if (source === vertex) {
            // A aresta está conectada ao objeto conectável
            console.log('Conectado ao objeto conectável');
        }
        });

        const style = graph.getStylesheet().getDefaultEdgeStyle();
        style[mxConstants.STYLE_STROKECOLOR] = '#000000'; 
        style[mxConstants.STYLE_STROKEWIDTH] = 2; 
        style[mxConstants.STYLE_ENDARROW] = 'classic'; 

        graph.setConnectable(true);
        graph.setMultigraph(false); 
        graph.connectionHandler.setCreateTarget(true);
        graph.connectionHandler.setCreateTargetMarker(new mxMarker(graph, '#00FF00', 8));

        // Habilita a desconexão de arestas
        graph.setDisconnectOnMove(false);

        // Configura o estilo da conexão (opcional)
        graph.connectionHandler.createEdgeState = function (me) {
            const edge = graph.createEdge(null, null, null, null, null, 'edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;endArrow=classic;');
            return new mxCellState(this.graph.view, edge, this.graph.getCellStyle(edge));
        };


    });

    //Botão Ator Linha de Vida
    document.getElementById('addActorLifeLineButton').addEventListener('click', function() {
        const parent = graph.getDefaultParent();
        const x = 100; 
        const y = 100; 
        const width = 45; 
        const height = 350; 

        
        const actorIconUrl = '../../static/assets/img/actorlifeline.png';

        const vertex = graph.insertVertex(
        parent,
        null,
        'Ator',
        x,
        y,
        width,
        height,
        'shape=image;image=' + actorIconUrl
        );

        vertex.geometry.offset = new mxPoint(0, 35);
        vertex.geometry.relative = false;
        vertex.geometry.anchorPoint = new mxPoint(0, 0);
        vertex.geometry.relative = false;
        vertex.geometry.labelPosition = mxConstants.ALIGN_LEFT + mxConstants.ALIGN_BOTTOM;

        vertex.style += ';verticalAlign=top;'; 

        
        graph.refresh();

        vertex.setVertex(true); 
        //vertex.setConnectable(false); 

        // isso faz criação de coneção de seta
        graph.connectionHandler.addListener(mxEvent.CONNECT, function (sender, evt) {
        const edge = evt.getProperty('cell'); 
        const source = graph.getModel().getTerminal(edge, true); 
        const target = graph.getModel().getTerminal(edge, false); 
        if (source === vertex) {
            // A aresta está conectada ao objeto conectável
            console.log('Conectado ao objeto conectável');
        }
        });

        const style = graph.getStylesheet().getDefaultEdgeStyle();
        style[mxConstants.STYLE_STROKECOLOR] = '#000000'; 
        style[mxConstants.STYLE_STROKEWIDTH] = 2; 
        style[mxConstants.STYLE_ENDARROW] = 'classic'; 

        graph.setConnectable(true);
        graph.setMultigraph(false); 
        graph.connectionHandler.setCreateTarget(true);
        graph.connectionHandler.setCreateTargetMarker(new mxMarker(graph, '#00FF00', 8));

        // Habilita a desconexão de arestas
        graph.setDisconnectOnMove(false);

        // Configura o estilo da conexão (opcional)
        graph.connectionHandler.createEdgeState = function (me) {
            const edge = graph.createEdge(null, null, null, null, null, 'edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;endArrow=classic;');
            return new mxCellState(this.graph.view, edge, this.graph.getCellStyle(edge));
        };
    });

    //cria Barra de ativação
    document.getElementById('addActivationBarButton').addEventListener('click', function() {
        const vertex = graph.insertVertex(graph.getDefaultParent(), null, '', 100, 100, 20, 160, 'color:white;fillColor=#FFFFFF;strokeColor=#000000;');
        
        // isso faz criação de coneção de seta
        graph.connectionHandler.addListener(mxEvent.CONNECT, function (sender, evt) {
        const edge = evt.getProperty('cell'); 
        const source = graph.getModel().getTerminal(edge, true); 
        const target = graph.getModel().getTerminal(edge, false); 
        if (source === vertex) {
            // A aresta está conectada ao objeto conectável
            console.log('Conectado ao objeto conectável');
        }
        });

        const style = graph.getStylesheet().getDefaultEdgeStyle();
        style[mxConstants.STYLE_STROKECOLOR] = '#000000'; 
        style[mxConstants.STYLE_STROKEWIDTH] = 2; 
        style[mxConstants.STYLE_ENDARROW] = 'classic'; 

        graph.setConnectable(true);
        graph.setMultigraph(false); 
        graph.connectionHandler.setCreateTarget(true);
        graph.connectionHandler.setCreateTargetMarker(new mxMarker(graph, '#00FF00', 8));

        // Habilita a desconexão de arestas
        graph.setDisconnectOnMove(false);

        // Configura o estilo da conexão (opcional)
        graph.connectionHandler.createEdgeState = function (me) {
            const edge = graph.createEdge(null, null, null, null, null, 'edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;endArrow=classic;');
            return new mxCellState(this.graph.view, edge, this.graph.getCellStyle(edge));
        };
    });

    //cria Linha
    document.getElementById('addLine1Button').addEventListener('click', function() {
        var vertex1 = graph.insertVertex(parent, '1', 'Vértice 1', 50, 50, 80, 30);
        var vertex2 = graph.insertVertex(parent, '2', 'Vértice 2', 200, 120, 80, 30);

        // Crie uma aresta (linha SVG) para conectar os vértices
        var edge = graph.insertEdge(parent, null, '', vertex1, vertex2, 'edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;endArrow=classic;fillColor=#FFFFFF;strokeColor=#000000;strokeWidth=2;');

        graph.removeCells([vertex1], false);
        graph.removeCells([vertex2], false);
        

   
    });

    //cria Linha
    document.getElementById('addLine2Button').addEventListener('click', function() {
        var vertex1 = graph.insertVertex(parent, '1', 'Vértice 1', 50, 50, 80, 30);
        var vertex2 = graph.insertVertex(parent, '2', 'Vértice 2', 200, 120, 80, 30);

        // Crie uma aresta (linha SVG) para conectar os vértices
        var edge = graph.insertEdge(parent, null, '', vertex1, vertex2, 'edgeStyle=straightEdgeStyle;rounded=0;orthogonalLoop=1;endArrow=classic;fillColor=#FFFFFF;strokeColor=#000000;strokeWidth=2;');

        graph.removeCells([vertex1], false);
        graph.removeCells([vertex2], false);
        

   
    });

    //cria Linha
    document.getElementById('addLine3Button').addEventListener('click', function() {
        var vertex1 = graph.insertVertex(parent, '1', 'Vértice 1', 50, 50, 80, 30);
        var vertex2 = graph.insertVertex(parent, '2', 'Vértice 2', 200, 120, 80, 30);

        // Crie uma aresta (linha SVG) para conectar os vértices
        var edge = graph.insertEdge(parent, null, '', vertex1, vertex2, 'edgeStyle=entityRelationEdgeStyle;rounded=0;orthogonalLoop=1;endArrow=classic;fillColor=#FFFFFF;strokeColor=#000000;strokeWidth=2;');

        graph.removeCells([vertex1], false);
        graph.removeCells([vertex2], false);
        

   
    });

    document.getElementById('addLine4Button').addEventListener('click', function() {
        var vertex1 = graph.insertVertex(parent, '1', 'Vértice 1', 50, 50, 80, 30);
        var vertex2 = graph.insertVertex(parent, '2', 'Vértice 2', 200, 120, 80, 30);

        // Crie uma aresta (linha SVG) para conectar os vértices
        var edge = graph.insertEdge(parent, null, '', vertex1, vertex2, 'edgeStyle=straightEdgeStyle;rounded=0;orthogonalLoop=1;startArrow=classic;endArrow=classic;fillColor=#FFFFFF;strokeColor=#000000;strokeWidth=2;');

        graph.removeCells([vertex1], false);
        graph.removeCells([vertex2], false);
        

   
    });

    document.getElementById('addLine5Button').addEventListener('click', function() {
        var vertex1 = graph.insertVertex(parent, '1', 'Vértice 1', 50, 50, 80, 30);
        var vertex2 = graph.insertVertex(parent, '2', 'Vértice 2', 200, 120, 80, 30);

        // Crie uma aresta (linha SVG) para conectar os vértices
        var edge = graph.insertEdge(parent, null, '', vertex1, vertex2, 'edgeStyle=orthogonalEdgeStyle;curved=1;rounded=0;endArrow=classic;fillColor=#FFFFFF;strokeColor=#000000;strokeWidth=2;');

        graph.removeCells([vertex1], false);
        graph.removeCells([vertex2], false);
        

   
    });

    document.getElementById('addLine6Button').addEventListener('click', function() {
        var vertex1 = graph.insertVertex(parent, '1', 'Vértice 1', 50, 50, 80, 30);
        var vertex2 = graph.insertVertex(parent, '2', 'Vértice 2', 200, 120, 80, 30);

        // Crie uma aresta (linha SVG) para conectar os vértices
        var edge = graph.insertEdge(parent, null, '', vertex1, vertex2, 'edgeStyle=straightEdgeStyle;rounded=0;orthogonalLoop=1;endArrow=false;fillColor=#FFFFFF;strokeColor=#000000;strokeWidth=2;');

        graph.removeCells([vertex1], false);
        graph.removeCells([vertex2], false);
        

   
    });

    document.getElementById('addLine7Button').addEventListener('click', function() {
        var vertex1 = graph.insertVertex(parent, '1', 'Vértice 1', 50, 50, 80, 30);
        var vertex2 = graph.insertVertex(parent, '2', 'Vértice 2', 200, 120, 80, 30);

        // Crie uma aresta (linha SVG) para conectar os vértices
        var edge = graph.insertEdge(parent, null, '', vertex1, vertex2, 'dashed=1;edgeStyle=straightEdgeStyle;rounded=0;orthogonalLoop=1;endArrow=false;fillColor=#FFFFFF;strokeColor=#000000;strokeWidth=2;');

        graph.removeCells([vertex1], false);
        graph.removeCells([vertex2], false);
        

   
    });
    
    document.getElementById('addLine8Button').addEventListener('click', function() {
        var vertex1 = graph.insertVertex(parent, '1', 'Vértice 1', 50, 50, 80, 30);
        var vertex2 = graph.insertVertex(parent, '2', 'Vértice 2', 200, 120, 80, 30);

        // Crie uma aresta (linha SVG) para conectar os vértices
        var edge = graph.insertEdge(parent, null, '', vertex1, vertex2, 'dashed=1;dashPattern=1 4;edgeStyle=straightEdgeStyle;rounded=0;orthogonalLoop=1;endArrow=false;fillColor=#FFFFFF;strokeColor=#000000;strokeWidth=2;');

        graph.removeCells([vertex1], false);
        graph.removeCells([vertex2], false);
        

   
    });

    document.getElementById('addLine9Button').addEventListener('click', function() {
        var vertex1 = graph.insertVertex(parent, '1', 'Vértice 1', 50, 50, 80, 30);
        var vertex2 = graph.insertVertex(parent, '2', 'Vértice 2', 200, 120, 80, 30);
        
        // Crie uma aresta (linha SVG) para conectar os vértices
        var edge = graph.insertEdge(parent, null, '', vertex1, vertex2, 'edgeStyle=straightEdgeStyle;rounded=0;orthogonalLoop=1;endArrow=diamondThin;strokeColor=#000000;strokeWidth=2;');

        graph.removeCells([vertex1], false);
        graph.removeCells([vertex2], false);
        

   
    });

    document.getElementById('addLine10Button').addEventListener('click', function() {
        var vertex1 = graph.insertVertex(parent, '1', 'Vértice 1', 50, 50, 80, 30);
        var vertex2 = graph.insertVertex(parent, '2', 'Vértice 2', 200, 120, 80, 30);
        
        // Crie uma aresta (linha SVG) para conectar os vértices
        var edge = graph.insertEdge(parent, null, '', vertex1, vertex2, 'dashed=1;edgeStyle=straightEdgeStyle;rounded=0;orthogonalLoop=1;endArrow=open;strokeColor=#000000;strokeWidth=2;');

        graph.removeCells([vertex1], false);
        graph.removeCells([vertex2], false);
        

   
    });

    document.getElementById('addLine11Button').addEventListener('click', function() {
        var vertex1 = graph.insertVertex(parent, '1', 'Vértice 1', 50, 50, 80, 30);
        var vertex2 = graph.insertVertex(parent, '2', 'Vértice 2', 200, 120, 80, 30);
        
        // Crie uma aresta (linha SVG) para conectar os vértices
        var edge = graph.insertEdge(parent, null, '', vertex1, vertex2, 'dashed=1;edgeStyle=straightEdgeStyle;rounded=0;orthogonalLoop=1;endArrow=classic;strokeColor=#000000;strokeWidth=2;');

        graph.removeCells([vertex1], false);
        graph.removeCells([vertex2], false);
        

   
    });

    document.getElementById('addLine12Button').addEventListener('click', function() {
        var vertex1 = graph.insertVertex(parent, '1', 'Vértice 1', 50, 50, 80, 30);
        var vertex2 = graph.insertVertex(parent, '2', 'Vértice 2', 200, 120, 80, 30);
        
        // Crie uma aresta (linha SVG) para conectar os vértices
        var edge = graph.insertEdge(parent, null, '', vertex1, vertex2, 'edgeStyle=straightEdgeStyle;rounded=0;orthogonalLoop=1;startArrow=diamond;endArrow=classic;strokeColor=#000000;strokeWidth=2;');

        graph.removeCells([vertex1], false);
        graph.removeCells([vertex2], false);
        

   
    });

    // funcao delete
    document.addEventListener('keydown', function (e) {
    if (e.key === 'Delete') {
        const cells = graph.getSelectionCells();

        if (cells && cells.length > 0) {
        graph.removeCells(cells);
        }
    }
    });

    // funcao Ctrl+C e Ctrl+V
    document.addEventListener('keydown', function (e) {
    if (e.ctrlKey) {
        if (e.key === 'c' || e.key === 'C') {
        copyCells();
        }

        if (e.key === 'v' || e.key === 'V') {
        pasteCells();
        }
    }
    });

    // Função para copiar células
    function copyCells() {
        const cells = graph.getSelectionCells();

        mxClipboard.copy(graph, cells);
    }

    // Função para colar células
    function pasteCells() {
        const cells = mxClipboard.paste(graph);

        if (cells) {
            graph.addCells(cells);
        }
    }

    // selecionar mais de um elemento e cria retangulo de seleção
    var selectedCells = [];

    // funcao pra arrastar varios
    function enableMultiSelection() {
    var container = graph.container;

    var isMouseDown = false;
    var startX, startY;
    var rubberband = document.createElement('div');
    rubberband.style.border = '1px dashed gray';
    rubberband.style.position = 'absolute';
    rubberband.style.backgroundColor = 'rgba(173, 216, 230, 0.3)';
    rubberband.style.display = 'none';

    container.appendChild(rubberband);

    mxEvent.addListener(container, 'mousedown', function(evt) {
        if (evt.which === 1) {
        isMouseDown = true;
        startX = mxEvent.getClientX(evt) - container.getBoundingClientRect().left;
        startY = mxEvent.getClientY(evt) - container.getBoundingClientRect().top;

        rubberband.style.display = 'none';
        graph.clearSelection();
        selectedCells = [];
        }
    });

    mxEvent.addListener(container, 'mousemove', function(evt) {
        if (isMouseDown) {
        var currentX = mxEvent.getClientX(evt) - container.getBoundingClientRect().left;
        var currentY = mxEvent.getClientY(evt) - container.getBoundingClientRect().top;

        var x = Math.min(startX, currentX);
        var y = Math.min(startY, currentY);
        var width = Math.abs(currentX - startX);
        var height = Math.abs(currentY - startY);

        rubberband.style.left = x + 'px';
        rubberband.style.top = y + 'px';
        rubberband.style.width = width + 'px';
        rubberband.style.height = height + 'px';
        rubberband.style.display = 'block';

        selectElementsInRect(graph, x, y, width, height);
        }
    });

    mxEvent.addListener(container, 'mouseup', function(evt) {
        if (isMouseDown) {
        isMouseDown = false;

        graph.setSelectionCells(selectedCells);

        mxEvent.addListener(container, 'click', function(evt) {
            mxEvent.removeListener(container, 'click');
        });

        rubberband.style.display = 'none';
        }
    });
    }

    // isso ajuda selecionar elementos dentro do retângulo
    function selectElementsInRect(graph, x, y, width, height) {
        var cells = graph.getChildVertices(graph.getDefaultParent());

        for (var i = 0; i < cells.length; i++) {
            var state = graph.view.getState(cells[i]);

            if (state != null) {
            var bounds = state;

            if (
                bounds.x >= x &&
                bounds.x + bounds.width <= x + width &&
                bounds.y >= y &&
                bounds.y + bounds.height <= y + height
            ) {
                selectedCells.push(cells[i]);
            }
            }
        }
    }

    // aqui eu chamo
    enableMultiSelection();

    //download diagrama
    document.getElementById('downloadXMLButton').addEventListener('click', function() {
        console.log("cheguei")
        
      // Salva o estado atual do grafo
      const encoder = new mxCodec();
      const node = encoder.encode(graph.getModel());
      const xml = mxUtils.getXml(node);

      // Cria um arquivo Blob
      const blob = new Blob([xml], { type: 'text/xml' });

      // Cria um objeto URL e inicia o download
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'diagrama.xml';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);

        // Salva o estado atual do grafo
        

    });


    document.getElementById('downloadPDFButton').addEventListener('click', function() {
        
    });
    

    //download png
    //Isso ocorre porque os navegadores têm uma política de segurança chamada Política da Mesma Origem (Same-Origin Policy), que restringe como um documento ou script carregado de uma origem pode interagir com um recurso de outra origem. Isso é uma precaução de segurança importante para evitar ataques de Cross-Site Scripting (XSS).
    //Quando você tenta carregar uma imagem localmente (por exemplo, a partir do sistema de arquivos do seu computador), o navegador considera isso como uma origem diferente. Portanto, por padrão, ele bloqueia a tentativa de carregar a imagem devido à Política da Mesma Origem.
    document.getElementById('downloadPNGButton').addEventListener('click', function() {
        var node = document.getElementById('graphContainer');

        domtoimage.toPng(node)
            .then(function (dataUrl) {
                var link = document.createElement('a');
                link.download = 'diagrama.png';
                link.href = dataUrl;
                console.log(dataUrl)
                link.click();
            })
            .catch(function (error) {
                console.error('Erro ao criar a imagem!', error);
            });
    });

    // Adiciona um ouvinte de eventos para carregar XML
    document.getElementById('fileInput').addEventListener('change', function(event) {
      const file = event.target.files[0];
      const fileNameDisplay = document.getElementById("fileNameDisplay");
        const field = document.getElementById("fileInput")
    
        const fileName = file.name;
        fileNameDisplay.innerText = `Esolha um arquivo .xml: ${fileName}`;

      if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
          const xml = e.target.result;
          loadGraphFromXml(xml);
        };
        reader.readAsText(file);
      }
    });

    // Função para carregar o gráfico a partir de um XML
    function loadGraphFromXml(xml) {
      const doc = mxUtils.parseXml(xml);
      const codec = new mxCodec(doc);
      codec.decode(doc.documentElement, graph.getModel());
    }

    //pega o click
    graph.addListener(mxEvent.DOUBLE_CLICK, function(sender, evt) {
        var cell = evt.getProperty('cell');
        if (cell) { 
            const style = graph.getCellStyle(cell);
            console.log(style[mxConstants.STYLE_SHAPE] )
            if (style[mxConstants.STYLE_SHAPE] === mxConstants.SHAPE_IMAGE) {
                elementoType = "eimagem"
            } else if (cell.isEdge()) {
                elementoType = "elinha"
            } else {
                elementoType = "naoeimagem"
            }
        }
        document.getElementById('labelInput').value=cell.value;
        
        if (cell) {
        openModal(cell.value);
        }
    });

    // Função para abrir o modal
    function openModal(content) {
        
        $("#modalStyle").modal({
            show: true
        });
    }
    
    //carregar imagem
    document.getElementById('imageInput').addEventListener('change', handleFileSelect, false);

    function handleFileSelect(event) {
    var file = event.target.files[0];

    if (!file) return;

    var reader = new FileReader();
    reader.onload = function(e) {
        console.log(e)
        var imageUrl = e.target.result;
        var img = new Image();
        img.onload = function() {
        var width = 100;
        var height = 100;
        
        var x = graph.container.offsetWidth / 2 - width / 2;
        var y = graph.container.offsetHeight / 2 - height / 2;
        
        importImage(imageUrl, x, y, width, height);
        };
        img.src = imageUrl;
    };
    reader.readAsDataURL(file);
    
    }

    // Função para importar imagem, conforme definida no exemplo anterior
    function importImage(url, x, y, width, height) {
        const vertex = graph.insertVertex(
        parent,
        null,
        '',
        x,
        y,
        width,
        height,
        'shape=image;image=' + url
        );
        graph.refresh();

        vertex.setVertex(true); 
        //vertex.setConnectable(false); 

        // isso faz criação de coneção de seta
        graph.connectionHandler.addListener(mxEvent.CONNECT, function (sender, evt) {
        const edge = evt.getProperty('cell'); 
        const source = graph.getModel().getTerminal(edge, true); 
        const target = graph.getModel().getTerminal(edge, false); 
        if (source === vertex) {
            console.log('Conectado ao objeto conectável');
        }
        });

        const style = graph.getStylesheet().getDefaultEdgeStyle();
        style[mxConstants.STYLE_STROKECOLOR] = '#000000'; 
        style[mxConstants.STYLE_STROKEWIDTH] = 2; 
        style[mxConstants.STYLE_ENDARROW] = 'classic'; 

        graph.setConnectable(true);
        graph.setMultigraph(false); 
        graph.connectionHandler.setCreateTarget(true);
        graph.connectionHandler.setCreateTargetMarker(new mxMarker(graph, '#00FF00', 8));
    
    
        var parent = graph.getDefaultParent();
        graph.getModel().beginUpdate();
        try {
            vertex = graph.addCell(vertex, parent);
        } finally {
            graph.getModel().endUpdate();
        }
    }


    //funcao crtl+z
    var undoManager = new mxUndoManager();

    graph.getModel().addListener(mxEvent.UNDO, function(sender, evt){
    undoManager.undoableEditHappened(evt.getProperty('edit'));
    });

    function undo() {
    if (undoManager.canUndo()) {
        undoManager.undo();
    } else {
        alert('Não há mais operações para desfazer.');
    }
    }

    document.addEventListener('keydown', function(event) {
    if (event.ctrlKey && event.key === 'z') {
        undo();
    }
    });


    //altera a cor 
    function updateFillColor() {
        const colorInput = document.getElementById('head');
        const colorValue = colorInput.value;

        setFillColor(colorValue);
        const selectionModel = graph.getSelectionModel();
        const cell = selectionModel.cells[0]; 
        
        if (cell) {
            graph.getModel().beginUpdate();
            try {
                
                if(elementoType == "eimagem"){
                    graph.setCellStyles(mxConstants.STYLE_IMAGE_BACKGROUND, colorValue, [cell]);
                } if(elementoType == "elinha"){
                    graph.setCellStyles(mxConstants.STYLE_STROKECOLOR, colorValue, [cell]);
                }else{
                    graph.setCellStyles(mxConstants.STYLE_FILLCOLOR, colorValue, [cell]);
                }
            } finally {
                graph.getModel().endUpdate();
            }
        }
    }
    
    //ajuda a alterar cor
    function setFillColor(color) {
        const selectionModel = graph.getSelectionModel();
        const cell = selectionModel.cells[0]; 
        

        if (cell) {
            graph.getModel().beginUpdate();
            try {
                if(elementoType == "eimagem"){
                    graph.setCellStyles(mxConstants.STYLE_IMAGE_BACKGROUND, color, [cell]);
                } if(elementoType == "elinha"){
                    graph.setCellStyles(mxConstants.STYLE_STROKECOLOR, color, [cell]);
                }else{
                    graph.setCellStyles(mxConstants.STYLE_FILLCOLOR, color, [cell]);
                }
                
            } finally {
                graph.getModel().endUpdate();
            }
        }
    }

    // Função para definir o texto do rótulo do elemento selecionado
    function setLabel() {
        const label = document.getElementById('labelInput').value;
        const selectionModel = graph.getSelectionModel();
        const cell = selectionModel.cells[0]; 
        if (cell) {
            graph.getModel().beginUpdate();
            try {
                graph.labelChanged(cell, label);
            } finally {
                graph.getModel().endUpdate();
            }
        }
        graph.refresh();
    }

    // Função para definir a fonte do rótulo do elemento selecionado
    function setFont() {
        const font = document.getElementById('fontInput').value;
        const selectionModel = graph.getSelectionModel();
        const cell = selectionModel.cells[0]; 
        if (cell) {
            graph.getModel().beginUpdate();
            try {
                graph.setCellStyles(mxConstants.STYLE_FONTFAMILY, font, [cell]);
            } finally {
                graph.getModel().endUpdate();
            }
        }
        graph.refresh();
    }

    // Função para definir o tamanho do texto do rótulo do elemento selecionado
    function setFontSize() {
        const fontSize = document.getElementById('fontSizeInput').value;
        const selectionModel = graph.getSelectionModel();
        const cell = selectionModel.cells[0]; 
        if (cell) {
            graph.getModel().beginUpdate();
            try {
                graph.setCellStyles(mxConstants.STYLE_FONTSIZE, fontSize, [cell]);
            } finally {
                graph.getModel().endUpdate();
            }
        }
        graph.refresh();
    }

    function setLabelColor() {
        const labelColor = document.getElementById('labelColorInput').value;
        const selectionModel = graph.getSelectionModel();
        const cell = selectionModel.cells[0];
        if (cell) {
            graph.getModel().beginUpdate();
            try {
                graph.setCellStyles(mxConstants.STYLE_FONTCOLOR, labelColor, [cell]);
            } finally {
                graph.getModel().endUpdate();
            }
        }
        graph.refresh();
    }


    //Isso faz o modal se mover
    var modal = document.getElementById('modalStyle');
    var isMovendo = false;
    var posicaoInicial = { x: 0, y: 0 };


    function iniciarMovimento(event) {
    isMovendo = true;
    posicaoInicial.x = event.clientX;
    posicaoInicial.y = event.clientY;
    }


    function moverModal(event) {
    if (isMovendo) {
        var offsetX = event.clientX - posicaoInicial.x;
        var offsetY = event.clientY - posicaoInicial.y;

        var novaPosicaoX = modal.offsetLeft + offsetX;
        var novaPosicaoY = modal.offsetTop + offsetY;

        modal.style.left = novaPosicaoX + 'px';
        modal.style.top = novaPosicaoY + 'px';

        posicaoInicial.x = event.clientX;
        posicaoInicial.y = event.clientY;
    }
    }

    function finalizarMovimento() {
    isMovendo = false;
    }

    modal.addEventListener('mousedown', iniciarMovimento);
    document.addEventListener('mousemove', moverModal);
    document.addEventListener('mouseup', finalizarMovimento);


    document.getElementById('associationButton').addEventListener('click', function() {
        creatingEdge = true;
    });

    document.addEventListener('DOMContentLoaded', function() {
        createGraph(document.getElementById('graphContainer'));
    });



    graph.addListener(mxEvent.CLICK, function(sender, evt) {
        const cell = evt.getProperty('cell');
        if (cell !== null && cell.isVertex()) {
            console.log('Clicou no nó:', cell.value);
        }
    });

    
    // Enviar dados do gráfico para o backend (Django) via AJAX para salvar
        document.getElementById('saveButton').addEventListener('click', function() {
            console.log("cheguei")
            // Salva o estado atual do grafo
            const encoder = new mxCodec();
            const node = encoder.encode(graph.getModel());
            const xml = new XMLSerializer().serializeToString(node);

        // Envia o XML para a view Django usando uma solicitação AJAX
        fetch('/salvar_modelagem', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/xml',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: xml
            })
            .then(response => {
            if (!response.ok) {
                throw new Error('Erro ao enviar o XML para a view Django. Status: ' + response.status);
            }
            console.log('XML enviado com sucesso para a view Django.');
            })
            .catch(error => {
            console.error('Erro ao enviar o XML para a view Django:', error);
            });
        });

    // Carregar dados do gráfico do backend (Django) via AJAX
    document.getElementById('loadButton').addEventListener('click', function() {
        fetch('/load-graph-data/')
        .then(response => response.json())
        .then(data => {
            // Carregar dados no gráfico
            if (data && data.data) {
                const xmlDoc = mxUtils.parseXml(data.data);
                const codec = new mxCodec(xmlDoc);
                codec.decode(xmlDoc.documentElement, graph.getModel());
            }
        })
        .catch(error => {
            console.error('Erro ao carregar o diagrama:', error);
        });
    });

    // Função para obter o token CSRF
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.startsWith(name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
</script>

<script>
    $(document).ready(function () {
        // Javascript method's body can be found in assets/js/demos.js
        demo.initDashboardPageCharts();

    });
</script>

{% endblock javascripts %}
